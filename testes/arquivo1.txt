A função memmove() em C copia um número especificado de bytes de uma área de memória para outra. Ela é especialmente útil quando a área de origem e a de destino podem se sobrepor, o que a função memcpy() não consegue fazer corretamente. 
Como usar:

    Incluir a biblioteca string.h: A função memmove() está definida nesta biblioteca.
    Definir a função:

C

    void *memmove(void *destination, const void *source, size_t num_bytes);

    destination: Ponteiro para o bloco de memória de destino.

source: Ponteiro para o bloco de memória de origem.
num_bytes: Número de bytes a serem copiados.

    Chamar a função:

C

    #include <stdio.h>
    #include <string.h>

    int main() {
        char source[] = "abcdefg";
        char destination[10];
        char *result;

        result = memmove(destination, source, 5); // Copia 5 bytes de 'source' para 'destination'
        destination[5] = '\0'; //  Adiciona um caractere nulo ao final de 'destination'

        printf("String de destino: %s\n", destination);
        return 0;
    }

Exemplos:

    Copiando com sobreposição:
    Se você estiver copiando uma parte de uma string para outra dentro da mesma string, memmove() garante que a operação seja realizada corretamente, evitando problemas de dados perdidos devido à sobreposição.
    Copiando entre strings diferentes:
    Se você estiver copiando dados de uma string para outra que não se sobrepõem, memcpy() também pode ser usada, mas memmove() ainda é mais seguro em caso de problemas inesperados. 

Principais diferenças entre memmove() e memcpy():

    memmove() é projetada para lidar com sobreposição entre a origem e o destino, enquanto memcpy() pode gerar resultados incorretos ou inesperados em situações de sobreposição.
    memmove() é mais lenta do que memcpy() porque ela implementa uma estratégia para lidar com a sobreposição, o que pode exigir mais processamento. 

Em resumo: Se você estiver preocupado com sobreposição, use memmove(). Se a sobreposição não for um problema, memcpy() pode ser uma opção mais rápida. 

/*****************************************************************************************************************************************************/

strcmp ()
Atualizado pela última vez: 2024-01-09

Compara duas sequências.

A função começa a comparar o primeiro caractere de cada sequência.. Se eles forem iguais uns aos outros, ele continuará com os pares a seguir até que os caracteres sejam diferentes ou até que o final da sequência mais curta seja atingido..
Sintaxe

strcmp(string1, string2)
Argumentos

    string1: primeira sequência de entrada para comparação.
    string2: segunda sequência de entrada para comparação.

Devoluções

Retorna um valor integral indicando o relacionamento entre as sequências:

    < 0 -o primeiro caractere que não corresponde possui um valor inferior em string1 do que em string2
    0 -o conteúdo de ambas as sequências é igual
    > 0 -o primeiro caractere que não corresponde possui um valor maior em string1 do que em string2

Exemplos

datatable(string1:string, string2:string)
["ABC","ABC",
"abc","ABC",
"ABC","abc",
"abcde","abc"]
| extend result = strcmp(string1,string2)

string1
	
string2
	
resultado
ABC	ABC	0
abc	ABC	1
ABC	abc	-1
abcde	abc	1

/*****************************************************************************************************************************************************/

Em C, a função localtime() converte um valor de tempo (em segundos desde 1 de janeiro de 1970, UTC) para a hora local, que é então armazenada numa estrutura do tipo struct tm. A estrutura tm contém os campos individuais da data e hora (ano, mês, dia, hora, minuto, segundo, etc.).
Como usar:

    Incluir a biblioteca:

C

    #include <time.h>

    Obter o valor de tempo:

Normalmente, obtém-se o tempo atual usando a função time(). Este valor representa o número de segundos desde 1 de janeiro de 1970, UTC. 
C

    time_t current_time;
    time(&current_time);

    Converte para a hora local:

Utilize a função localtime() para converter o tempo em segundos para a hora local, armazenando-o numa estrutura struct tm.
C

    struct tm *local_time;
    local_time = localtime(&current_time);

    Acessar os dados da hora local:

A estrutura local_time contém os campos individuais da data e hora. Pode acessar esses campos, por exemplo:
C

    int year = local_time->tm_year + 1900; // Ano (contando desde 1900)
    int month = local_time->tm_mon + 1;   // Mês (1-12)
    int day = local_time->tm_mday;       // Dia do mês
    int hour = local_time->tm_hour;       // Hora (0-23)
    int minute = local_time->tm_min;      // Minuto (0-59)
    int second = local_time->tm_sec;      // Segundo (0-59)

Exemplo completo:
C

#include <stdio.h>
#include <time.h>

int main() {
    time_t current_time;
    struct tm *local_time;

    time(&current_time);
    local_time = localtime(&current_time);

    printf("Data e hora local: %02d/%02d/%04d %02d:%02d:%02d\n",
           local_time->tm_mday, local_time->tm_mon + 1, local_time->tm_year + 1900,
           local_time->tm_hour, local_time->tm_min, local_time->tm_sec);

    return 0;
}

Notas:

    A função localtime() retorna um ponteiro para a estrutura struct tm.
    Os campos na estrutura struct tm são inteiros, então é preciso formatar a saída para obter o formato desejado.
    A estrutura struct tm é modificada pela função localtime(), portanto, é importante verificar se não se está a usar um buffer estático que possa ser sobrescrito por chamadas subsequentes a localtime(). Para evitar isso, pode usar a versão localtime_r(), que não utiliza um buffer estático.
    Se você precisa lidar com datas e horas de forma mais flexível, pode considerar o uso de funções como strftime() para formatar a data e hora como uma string. 
